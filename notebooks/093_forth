{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Forth\n",
    "\n",
    "Implement an evaluator for a very simple subset of Forth.\n",
    "\n",
    "[Forth](https://en.wikipedia.org/wiki/Forth_%28programming_language%29)\n",
    "is a stack-based programming language. Implement a very basic evaluator\n",
    "for a small subset of Forth.\n",
    "\n",
    "Your evaluator has to support the following words:\n",
    "\n",
    "- `+`, `-`, `*`, `/` (integer arithmetic)\n",
    "- `DUP`, `DROP`, `SWAP`, `OVER` (stack manipulation)\n",
    "\n",
    "Your evaluator also has to support defining new words using the\n",
    "customary syntax: `: word-name definition ;`.\n",
    "\n",
    "To keep things simple the only data type you need to support is signed\n",
    "integers of at least 16 bits size.\n",
    "\n",
    "You should use the following rules for the syntax: a number is a\n",
    "sequence of one or more (ASCII) digits, a word is a sequence of one or\n",
    "more letters, digits, symbols or punctuation that is not a number.\n",
    "(Forth probably uses slightly different rules, but this is close\n",
    "enough.)\n",
    "\n",
    "Words are case-insensitive.\n",
    "\n",
    "## Exception messages\n",
    "\n",
    "Sometimes it is necessary to raise an exception. When you do this, you should include a meaningful error message to\n",
    "indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. Not\n",
    "every exercise will require you to raise an exception, but for those that do, the tests will only pass if you include\n",
    "a message.\n",
    "\n",
    "To raise a message with an exception, just write it as an argument to the exception type. For example, instead of\n",
    "`raise Exception`, you should write:\n",
    "\n",
    "```python\n",
    "raise Exception(\"Meaningful message indicating the source of the error\")\n",
    "```\n",
    "\n",
    "## Running the tests\n",
    "\n",
    "To run the tests, run the appropriate command below ([why they are different](https://github.com/pytest-dev/pytest/issues/1629#issue-161422224)):\n",
    "\n",
    "- Python 2.7: `py.test forth_test.py`\n",
    "- Python 3.3+: `pytest forth_test.py`\n",
    "\n",
    "Alternatively, you can tell Python to run the pytest module (allowing the same command to be used regardless of Python version):\n",
    "`python -m pytest forth_test.py`\n",
    "\n",
    "### Common `pytest` options\n",
    "\n",
    "- `-v` : enable verbose output\n",
    "- `-x` : stop running tests on first failure\n",
    "- `--ff` : run failures from previous test before running other test cases\n",
    "\n",
    "For other options, see `python -m pytest -h`\n",
    "\n",
    "## Submitting Exercises\n",
    "\n",
    "Note that, when trying to submit an exercise, make sure the solution is in the `$EXERCISM_WORKSPACE/python/forth` directory.\n",
    "\n",
    "You can find your Exercism workspace by running `exercism debug` and looking for the line that starts with `Workspace`.\n",
    "\n",
    "For more detailed information about running tests, code style and linting,\n",
    "please see the [help page](http://exercism.io/languages/python).\n",
    "\n",
    "## Submitting Incomplete Solutions\n",
    "\n",
    "It's possible to submit an incomplete solution so you can see how others have completed the exercise.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class StackUnderflowError(Exception):\n",
    "    pass\n",
    "\n",
    "\n",
    "def evaluate(input_data):\n",
    "    pass\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import unittest\n",
    "\n",
    "\n",
    "\n",
    "# Tests adapted from `problem-specifications//canonical-data.json` @ v1.5.0\n",
    "# Tests for case-insensitivity are track-specific\n",
    "\n",
    "class ForthParsingTest(unittest.TestCase):\n",
    "    def test_numbers_just_get_pushed_to_stack(self):\n",
    "        input_data = [\"1 2 3 4 5\"]\n",
    "        expected = [1, 2, 3, 4, 5]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "\n",
    "class ForthAdditionTest(unittest.TestCase):\n",
    "    def test_can_add_two_numbers(self):\n",
    "        input_data = [\"1 2 +\"]\n",
    "        expected = [3]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"+\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_there_is_only_one_value_on_the_stack(self):\n",
    "        input_data = [\"1 +\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthSubtractionTest(unittest.TestCase):\n",
    "    def test_can_subtract_two_numbers(self):\n",
    "        input_data = [\"3 4 -\"]\n",
    "        expected = [-1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"-\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_there_is_only_one_value_on_the_stack(self):\n",
    "        input_data = [\"1 -\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthMultiplicationTest(unittest.TestCase):\n",
    "    def test_can_multiply_two_numbers(self):\n",
    "        input_data = [\"2 4 *\"]\n",
    "        expected = [8]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"*\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_there_is_only_one_value_on_the_stack(self):\n",
    "        input_data = [\"1 *\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthDivisionTest(unittest.TestCase):\n",
    "    def test_can_divide_two_numbers(self):\n",
    "        input_data = [\"12 3 /\"]\n",
    "        expected = [4]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_performs_integer_division(self):\n",
    "        input_data = [\"8 3 /\"]\n",
    "        expected = [2]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_dividing_by_zero(self):\n",
    "        input_data = [\"4 0 /\"]\n",
    "        with self.assertRaisesWithMessage(ZeroDivisionError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"/\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_there_is_only_one_value_on_the_stack(self):\n",
    "        input_data = [\"1 /\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthCombinedArithmeticTest(unittest.TestCase):\n",
    "    def test_addition_and_subtraction(self):\n",
    "        input_data = [\"1 2 + 4 -\"]\n",
    "        expected = [-1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_multiplication_and_division(self):\n",
    "        input_data = [\"2 4 * 3 /\"]\n",
    "        expected = [2]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "\n",
    "class ForthDupTest(unittest.TestCase):\n",
    "    def test_copies_a_value_on_the_stack(self):\n",
    "        input_data = [\"1 dup\"]\n",
    "        expected = [1, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_copies_the_top_value_on_the_stack(self):\n",
    "        input_data = [\"1 2 dup\"]\n",
    "        expected = [1, 2, 2]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"dup\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthDropTest(unittest.TestCase):\n",
    "    def test_removes_the_top_value_on_the_stack_if_it_is_the_only_one(self):\n",
    "        input_data = [\"1 DROP\"]\n",
    "        expected = []\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_removes_the_top_value_on_the_stack_if_it_not_the_only_one(self):\n",
    "        input_data = [\"3 4 DROP\"]\n",
    "        expected = [3]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"drop\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthSwapTest(unittest.TestCase):\n",
    "    def test_swaps_only_two_values_on_stack(self):\n",
    "        input_data = [\"1 2 SWAP\"]\n",
    "        expected = [2, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_swaps_two_two_values_on_stack(self):\n",
    "        input_data = [\"1 2 3 SWAP\"]\n",
    "        expected = [1, 3, 2]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"swap\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_there_is_only_one_value_on_the_stack(self):\n",
    "        input_data = [\"1 swap\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthOverTest(unittest.TestCase):\n",
    "    def test_copies_the_second_element_if_there_are_only_two(self):\n",
    "        input_data = [\"1 2 OVER\"]\n",
    "        expected = [1, 2, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_copies_the_second_element_if_there_are_more_than_two(self):\n",
    "        input_data = [\"1 2 3 OVER\"]\n",
    "        expected = [1, 2, 3, 2]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_errors_if_there_is_nothing_on_the_stack(self):\n",
    "        input_data = [\"over\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_there_is_only_one_value_on_the_stack(self):\n",
    "        input_data = [\"1 over\"]\n",
    "        with self.assertRaisesWithMessage(StackUnderflowError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthUserDefinedWordsTest(unittest.TestCase):\n",
    "    def test_can_consist_of_built_in_words(self):\n",
    "        input_data = [\n",
    "            \": dup-twice dup dup ;\",\n",
    "            \"1 dup-twice\"\n",
    "        ]\n",
    "        expected = [1, 1, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_execute_in_the_right_order(self):\n",
    "        input_data = [\n",
    "            \": countup 1 2 3 ;\",\n",
    "            \"countup\"\n",
    "        ]\n",
    "        expected = [1, 2, 3]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_can_override_other_user_defined_words(self):\n",
    "        input_data = [\n",
    "            \": foo dup ;\",\n",
    "            \": foo dup dup ;\",\n",
    "            \"1 foo\"\n",
    "        ]\n",
    "        expected = [1, 1, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_can_override_built_in_words(self):\n",
    "        input_data = [\n",
    "            \": swap dup ;\",\n",
    "            \"1 swap\"\n",
    "        ]\n",
    "        expected = [1, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_can_override_built_in_operators(self):\n",
    "        input_data = [\n",
    "            \": + * ;\",\n",
    "            \"3 4 +\"\n",
    "        ]\n",
    "        expected = [12]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_cannot_redefine_numbers(self):\n",
    "        input_data = [\": 1 2 ;\"]\n",
    "        with self.assertRaisesWithMessage(ValueError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    def test_errors_if_executing_a_non_existent_word(self):\n",
    "        input_data = [\"foo\"]\n",
    "        with self.assertRaisesWithMessage(ValueError):\n",
    "            evaluate(input_data)\n",
    "\n",
    "    # Utility functions\n",
    "    def setUp(self):\n",
    "        try:\n",
    "            self.assertRaisesRegex\n",
    "        except AttributeError:\n",
    "            self.assertRaisesRegex = self.assertRaisesRegexp\n",
    "\n",
    "    def assertRaisesWithMessage(self, exception):\n",
    "        return self.assertRaisesRegex(exception, r\".+\")\n",
    "\n",
    "\n",
    "class ForthCaseInsensitivityTest(unittest.TestCase):\n",
    "    def test_dup_is_case_insensitive(self):\n",
    "        input_data = [\"1 DUP Dup dup\"]\n",
    "        expected = [1, 1, 1, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_drop_is_case_insensitive(self):\n",
    "        input_data = [\"1 2 3 4 DROP Drop drop\"]\n",
    "        expected = [1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_swap_is_case_insensitive(self):\n",
    "        input_data = [\"1 2 SWAP 3 Swap 4 swap\"]\n",
    "        expected = [2, 3, 4, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_over_is_case_insensitive(self):\n",
    "        input_data = [\"1 2 OVER Over over\"]\n",
    "        expected = [1, 2, 1, 2, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_user_defined_words_are_case_insensitive(self):\n",
    "        input_data = [\n",
    "            \": foo dup ;\",\n",
    "            \"1 FOO Foo foo\"\n",
    "        ]\n",
    "        expected = [1, 1, 1, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "    def test_definitions_are_case_insensitive(self):\n",
    "        input_data = [\n",
    "            \": SWAP DUP Dup dup ;\",\n",
    "            \"1 swap\"\n",
    "        ]\n",
    "        expected = [1, 1, 1, 1]\n",
    "        self.assertEqual(evaluate(input_data), expected)\n",
    "\n",
    "\n",
    "unittest.main(argv=[''], exit=False)\n"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
