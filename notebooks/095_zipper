{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Zipper\n",
    "\n",
    "Creating a zipper for a binary tree.\n",
    "\n",
    "[Zippers](https://en.wikipedia.org/wiki/Zipper_%28data_structure%29) are\n",
    "a purely functional way of navigating within a data structure and\n",
    "manipulating it.  They essentially contain a data structure and a\n",
    "pointer into that data structure (called the focus).\n",
    "\n",
    "For example given a rose tree (where each node contains a value and a\n",
    "list of child nodes) a zipper might support these operations:\n",
    "\n",
    "- `from_tree` (get a zipper out of a rose tree, the focus is on the root node)\n",
    "- `to_tree` (get the rose tree out of the zipper)\n",
    "- `value` (get the value of the focus node)\n",
    "- `prev` (move the focus to the previous child of the same parent,\n",
    "  returns a new zipper)\n",
    "- `next` (move the focus to the next child of the same parent, returns a\n",
    "  new zipper)\n",
    "- `up` (move the focus to the parent, returns a new zipper)\n",
    "- `set_value` (set the value of the focus node, returns a new zipper)\n",
    "- `insert_before` (insert a new subtree before the focus node, it\n",
    "  becomes the `prev` of the focus node, returns a new zipper)\n",
    "- `insert_after` (insert a new subtree after the focus node, it becomes\n",
    "  the `next` of the focus node, returns a new zipper)\n",
    "- `delete` (removes the focus node and all subtrees, focus moves to the\n",
    "  `next` node if possible otherwise to the `prev` node if possible,\n",
    "  otherwise to the parent node, returns a new zipper)\n",
    "\n",
    "## Exception messages\n",
    "\n",
    "Sometimes it is necessary to raise an exception. When you do this, you should include a meaningful error message to\n",
    "indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. Not\n",
    "every exercise will require you to raise an exception, but for those that do, the tests will only pass if you include\n",
    "a message.\n",
    "\n",
    "To raise a message with an exception, just write it as an argument to the exception type. For example, instead of\n",
    "`raise Exception`, you should write:\n",
    "\n",
    "```python\n",
    "raise Exception(\"Meaningful message indicating the source of the error\")\n",
    "```\n",
    "\n",
    "## Running the tests\n",
    "\n",
    "To run the tests, run the appropriate command below ([why they are different](https://github.com/pytest-dev/pytest/issues/1629#issue-161422224)):\n",
    "\n",
    "- Python 2.7: `py.test zipper_test.py`\n",
    "- Python 3.3+: `pytest zipper_test.py`\n",
    "\n",
    "Alternatively, you can tell Python to run the pytest module (allowing the same command to be used regardless of Python version):\n",
    "`python -m pytest zipper_test.py`\n",
    "\n",
    "### Common `pytest` options\n",
    "\n",
    "- `-v` : enable verbose output\n",
    "- `-x` : stop running tests on first failure\n",
    "- `--ff` : run failures from previous test before running other test cases\n",
    "\n",
    "For other options, see `python -m pytest -h`\n",
    "\n",
    "## Submitting Exercises\n",
    "\n",
    "Note that, when trying to submit an exercise, make sure the solution is in the `$EXERCISM_WORKSPACE/python/zipper` directory.\n",
    "\n",
    "You can find your Exercism workspace by running `exercism debug` and looking for the line that starts with `Workspace`.\n",
    "\n",
    "For more detailed information about running tests, code style and linting,\n",
    "please see the [help page](http://exercism.io/languages/python).\n",
    "\n",
    "## Submitting Incomplete Solutions\n",
    "\n",
    "It's possible to submit an incomplete solution so you can see how others have completed the exercise.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Zipper(object):\n",
    "    @staticmethod\n",
    "    def from_tree(tree):\n",
    "        pass\n",
    "\n",
    "    def value(self):\n",
    "        pass\n",
    "\n",
    "    def set_value(self):\n",
    "        pass\n",
    "\n",
    "    def left(self):\n",
    "        pass\n",
    "\n",
    "    def set_left(self):\n",
    "        pass\n",
    "\n",
    "    def right(self):\n",
    "        pass\n",
    "\n",
    "    def set_right(self):\n",
    "        pass\n",
    "\n",
    "    def up(self):\n",
    "        pass\n",
    "\n",
    "    def to_tree(self):\n",
    "        pass\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import unittest\n",
    "\n",
    "\n",
    "\n",
    "# Tests adapted from `problem-specifications//canonical-data.json` @ v1.1.0\n",
    "\n",
    "class ZipperTest(unittest.TestCase):\n",
    "    def bt(self, value, left, right):\n",
    "        return {\n",
    "            'value': value,\n",
    "            'left': left,\n",
    "            'right': right\n",
    "        }\n",
    "\n",
    "    def leaf(self, value):\n",
    "        return self.bt(value, None, None)\n",
    "\n",
    "    def create_trees(self):\n",
    "        t1 = self.bt(1, self.bt(2, None, self.leaf(3)), self.leaf(4))\n",
    "        t2 = self.bt(1, self.bt(5, None, self.leaf(3)), self.leaf(4))\n",
    "        t3 = self.bt(1, self.bt(2, self.leaf(5), self.leaf(3)), self.leaf(4))\n",
    "        t4 = self.bt(1, self.leaf(2), self.leaf(4))\n",
    "        return (t1, t2, t3, t4)\n",
    "\n",
    "    def test_data_is_retained(self):\n",
    "        t1, _, _, _ = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        tree = zipper.to_tree()\n",
    "        self.assertEqual(tree, t1)\n",
    "\n",
    "    def test_left_and_right_value(self):\n",
    "        t1, _, _, _ = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        self.assertEqual(zipper.left().right().value(), 3)\n",
    "\n",
    "    def test_dead_end(self):\n",
    "        t1, _, _, _ = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        self.assertIsNone(zipper.left().left())\n",
    "\n",
    "    def test_tree_from_deep_focus(self):\n",
    "        t1, _, _, _ = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        self.assertEqual(zipper.left().right().to_tree(), t1)\n",
    "\n",
    "    def test_set_value(self):\n",
    "        t1, t2, _, _ = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        updatedZipper = zipper.left().set_value(5)\n",
    "        tree = updatedZipper.to_tree()\n",
    "        self.assertEqual(tree, t2)\n",
    "\n",
    "    def test_set_left_with_value(self):\n",
    "        t1, _, t3, _ = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        updatedZipper = zipper.left().set_left(self.leaf(5))\n",
    "        tree = updatedZipper.to_tree()\n",
    "        self.assertEqual(tree, t3)\n",
    "\n",
    "    def test_set_right_to_none(self):\n",
    "        t1, _, _, t4 = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        updatedZipper = zipper.left().set_right(None)\n",
    "        tree = updatedZipper.to_tree()\n",
    "        self.assertEqual(tree, t4)\n",
    "\n",
    "    def test_different_paths_to_same_zipper(self):\n",
    "        t1, _, _, _ = self.create_trees()\n",
    "        zipper = Zipper.from_tree(t1)\n",
    "        self.assertEqual(zipper.left().up().right().to_tree(),\n",
    "                         zipper.right().to_tree())\n",
    "\n",
    "\n",
    "unittest.main(argv=[''], exit=False)\n"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
